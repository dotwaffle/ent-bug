// Code generated by ent, DO NOT EDIT.

package ogent

import (
	"context"
	"net/http"

	"entgo.io/bug/ent"
	"entgo.io/bug/ent/thing"
	"entgo.io/bug/ent/thinghttp"
	"github.com/go-faster/jx"
)

// OgentHandler implements the ogen generated Handler interface and uses Ent as data layer.
type OgentHandler struct {
	client *ent.Client
}

// NewOgentHandler returns a new OgentHandler.
func NewOgentHandler(c *ent.Client) *OgentHandler { return &OgentHandler{c} }

// rawError renders err as json string.
func rawError(err error) jx.Raw {
	var e jx.Encoder
	e.Str(err.Error())
	return e.Bytes()
}

// CreateThing handles POST /things requests.
func (h *OgentHandler) CreateThing(ctx context.Context, req *CreateThingReq) (CreateThingRes, error) {
	b := h.client.Thing.Create()
	// Add all fields.
	b.SetAge(req.Age)
	b.SetName(req.Name)
	// Add all edges.
	b.AddProbedByIDs(req.ProbedBy...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Thing.Query().Where(thing.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewThingCreate(e), nil
}

// ReadThing handles GET /things/{id} requests.
func (h *OgentHandler) ReadThing(ctx context.Context, params ReadThingParams) (ReadThingRes, error) {
	q := h.client.Thing.Query().Where(thing.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewThingRead(e), nil
}

// UpdateThing handles PATCH /things/{id} requests.
func (h *OgentHandler) UpdateThing(ctx context.Context, req *UpdateThingReq, params UpdateThingParams) (UpdateThingRes, error) {
	b := h.client.Thing.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Age.Get(); ok {
		b.SetAge(v)
	}
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	// Add all edges.
	if req.ProbedBy != nil {
		b.ClearProbedBy().AddProbedByIDs(req.ProbedBy...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Thing.Query().Where(thing.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewThingUpdate(e), nil
}

// DeleteThing handles DELETE /things/{id} requests.
func (h *OgentHandler) DeleteThing(ctx context.Context, params DeleteThingParams) (DeleteThingRes, error) {
	err := h.client.Thing.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteThingNoContent), nil

}

// ListThing handles GET /things requests.
func (h *OgentHandler) ListThing(ctx context.Context, params ListThingParams) (ListThingRes, error) {
	q := h.client.Thing.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewThingLists(es)
	return (*ListThingOKApplicationJSON)(&r), nil
}

// ListThingProbedBy handles GET /things/{id}/probed-by requests.
func (h *OgentHandler) ListThingProbedBy(ctx context.Context, params ListThingProbedByParams) (ListThingProbedByRes, error) {
	q := h.client.Thing.Query().Where(thing.IDEQ(params.ID)).QueryProbedBy()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewThingProbedByLists(es)
	return (*ListThingProbedByOKApplicationJSON)(&r), nil
}

// CreateThingHTTP handles POST /thing-htt-ps requests.
func (h *OgentHandler) CreateThingHTTP(ctx context.Context, req *CreateThingHTTPReq) (CreateThingHTTPRes, error) {
	b := h.client.ThingHTTP.Create()
	// Add all fields.
	b.SetAge(req.Age)
	b.SetName(req.Name)
	// Add all edges.
	b.AddProbesHTTPIDs(req.ProbesHTTP...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.ThingHTTP.Query().Where(thinghttp.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewThingHTTPCreate(e), nil
}

// ReadThingHTTP handles GET /thing-htt-ps/{id} requests.
func (h *OgentHandler) ReadThingHTTP(ctx context.Context, params ReadThingHTTPParams) (ReadThingHTTPRes, error) {
	q := h.client.ThingHTTP.Query().Where(thinghttp.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewThingHTTPRead(e), nil
}

// UpdateThingHTTP handles PATCH /thing-htt-ps/{id} requests.
func (h *OgentHandler) UpdateThingHTTP(ctx context.Context, req *UpdateThingHTTPReq, params UpdateThingHTTPParams) (UpdateThingHTTPRes, error) {
	b := h.client.ThingHTTP.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Age.Get(); ok {
		b.SetAge(v)
	}
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	// Add all edges.
	if req.ProbesHTTP != nil {
		b.ClearProbesHTTP().AddProbesHTTPIDs(req.ProbesHTTP...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.ThingHTTP.Query().Where(thinghttp.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewThingHTTPUpdate(e), nil
}

// DeleteThingHTTP handles DELETE /thing-htt-ps/{id} requests.
func (h *OgentHandler) DeleteThingHTTP(ctx context.Context, params DeleteThingHTTPParams) (DeleteThingHTTPRes, error) {
	err := h.client.ThingHTTP.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteThingHTTPNoContent), nil

}

// ListThingHTTP handles GET /thing-htt-ps requests.
func (h *OgentHandler) ListThingHTTP(ctx context.Context, params ListThingHTTPParams) (ListThingHTTPRes, error) {
	q := h.client.ThingHTTP.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewThingHTTPLists(es)
	return (*ListThingHTTPOKApplicationJSON)(&r), nil
}

// ListThingHTTPProbesHTTP handles GET /thing-htt-ps/{id}/probes-http requests.
func (h *OgentHandler) ListThingHTTPProbesHTTP(ctx context.Context, params ListThingHTTPProbesHTTPParams) (ListThingHTTPProbesHTTPRes, error) {
	q := h.client.ThingHTTP.Query().Where(thinghttp.IDEQ(params.ID)).QueryProbesHTTP()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewThingHTTPProbesHTTPLists(es)
	return (*ListThingHTTPProbesHTTPOKApplicationJSON)(&r), nil
}
